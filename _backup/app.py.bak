from flask import Flask, jsonify, request, render_template, send_file, redirect, session, url_for
from flask_sqlalchemy import SQLAlchemy
from models import db, SeatingTable, ReservationRecord
from datetime import datetime, date, timedelta
from functools import wraps
from export import export_data_to_csv, OUTPUT_FILENAME 

# å»ºç«‹ Flask æ‡‰ç”¨ç¨‹å¼å¯¦ä¾‹
app = Flask(__name__)

# --- 1. é…ç½®è¨­å®š ---
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///db.sqlite3' 
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False 
app.config['SECRET_KEY'] = 'YOUR_SESSION_SECRET_KEY_888888' 
db.init_app(app) 

# --- 2. ç®¡ç†å“¡èˆ‡åº§ä½æ•¸æ“šè¨­å®š ---
ADMIN_USERNAME = 'admin'
ADMIN_PASSWORD = '888888' 

# 2.1. ğŸ“Œ åº§ä½æ•¸æ“šè‡ªå‹•ç”Ÿæˆé‚è¼¯ (108 æ¡Œä½ˆå±€)
INITIAL_SEATING_DATA = {}

TOTAL_ROWS = 9
TABLES_PER_ROW = 12 # ç¸½å…± 12 æ¡Œ (å·¦ 6 + å³ 6)
SEATS_PER_TABLE = 10 # æ¯æ¡Œ 10 å€‹åº§ä½

ZONE_CONFIGS = [
    {"name": "Zone A (Stage View)", "rows": 3, "color_class": "ZoneA"},
    {"name": "Zone B (Mid-hall)", "rows": 3, "color_class": "ZoneB"},
    {"name": "Zone C (Back)", "rows": 3, "color_class": "ZoneC"},
]

current_table_num = 1

# æ ¹æ“š ZONE_CONFIGS ç”Ÿæˆ 108 å¼µæ¡Œå­
for config in ZONE_CONFIGS:
    zone_name = config["name"]
    for _ in range(config["rows"]):
        for _ in range(TABLES_PER_ROW):
            table_id = f"T{current_table_num:03d}" 
            INITIAL_SEATING_DATA[table_id] = {
                "zone": zone_name,
                "total": SEATS_PER_TABLE
            }
            current_table_num += 1

# --- 3. èªè­‰è£é£¾å™¨ (ä¸è®Š) ---
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('logged_in'):
            return redirect(url_for('login'))
        return f(*args, **kwargs)
    return decorated_function


# ===============================================
#                 è·¯ç”±å®šç¾©
# ===============================================

# --- R1: é¦–é  / å“¡å·¥ä»‹é¢ (ä¸è®Š) ---
@app.route('/')
def index():
    return render_template('index.html')

# --- R2, R3, R4 ç™»å…¥/ç™»å‡º/ç®¡ç†å“¡/å…¬é–‹æŸ¥è©¢é é¢ (ä¸è®Š) ---
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if username == ADMIN_USERNAME and password == ADMIN_PASSWORD:
            session['logged_in'] = True
            session['username'] = username
            return redirect(url_for('admin_panel'))
        else:
            return render_template('login.html', error='Invalid credentials.')
    
    if session.get('logged_in'):
        return redirect(url_for('admin_panel'))

    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    return redirect(url_for('login'))


@app.route('/admin')
@login_required 
def admin_panel():
    return render_template('admin.html', username=session.get('username')) 

@app.route('/records')
def public_records_panel():
    return render_template('reports.html') 


# --- A1: åº§ä½ç‹€æ…‹ API (å…¬é–‹) ---
@app.route('/api/status', methods=['GET'])
def get_seating_status():
    with app.app_context():
        tables = SeatingTable.query.all()
        seating_inventory = {table.table_id: table.to_dict() for table in tables}
        return jsonify(seating_inventory)


# --- A2: é è¨‚ API (å…¬é–‹ - å–®ä¸€ Login ID å”¯ä¸€) ---
@app.route('/api/reserve', methods=['POST'])
def reserve_seats():
    data = request.get_json()
    table_id = data.get('table_id')
    seats_to_take_raw = data.get('seats_to_take') # ğŸ“Œ æ¥æ”¶åŸå§‹æ•¸æ“š
    employee_name = data.get('employee_name') 
    login_id = data.get('login_id')
    
    # ğŸ“Œ ä¿®æ­£ï¼šå¼·åˆ¶è½‰æ›ç‚ºæ•´æ•¸ï¼Œé¿å… isinstance éŒ¯èª¤
    try:
        seats_to_take = int(seats_to_take_raw)
    except (ValueError, TypeError):
        return jsonify({"success": False, "message": "Invalid seat count provided."}), 400


    if not all([table_id, seats_to_take, login_id]):
        return jsonify({"success": False, "message": "Incomplete request data. Please provide table ID, number of seats, and Login ID."}), 400
    if not 1 <= seats_to_take <= 4:
        return jsonify({"success": False, "message": "The number of seats to reserve must be between 1 and 4."}), 400

    try:
        with app.app_context():
            
            existing_reservation = ReservationRecord.query.filter_by(login_id=login_id).first()
            if existing_reservation:
                return jsonify({
                    "success": False, 
                    "message": f"Reservation failed: Login ID '{login_id}' has already reserved a seat at Table {existing_reservation.table_id}. Duplicated reservations are not allowed.",
                    "status": "DUPLICATE_ENTRY"
                }), 409

            table = db.session.query(SeatingTable).filter_by(table_id=table_id).with_for_update().first()

            if not table:
                return jsonify({"success": False, "message": f"Table ID {table_id} not found."}), 404
            if table.seats_left < seats_to_take:
                return jsonify({
                    "success": False, 
                    "message": f"Reservation failed: Only {table.seats_left} seat(s) left at Table {table_id}, which is less than {seats_to_take} requested.",
                    "seats_left": table.seats_left
                }), 409

            table.seats_left -= seats_to_take
            new_reservation = ReservationRecord(
                table_id=table_id,
                login_id=login_id,
                employee_name=employee_name,
                seats_taken=seats_to_take
            )
            db.session.add(new_reservation)
            db.session.commit()
            
            success_message = f"Success! {employee_name} ({login_id}) reserved {seats_to_take} seat(s) at Table {table_id}."

            return jsonify({
                "success": True,
                "message": success_message,
                "seats_left": table.seats_left
            })

    except Exception as e:
        db.session.rollback()
        print(f"è³‡æ–™åº«éŒ¯èª¤: {e}")
        return jsonify({"success": False, "message": "Internal server error. Reservation failed."}), 500


# --- A3: é è¨‚å ±è¡¨ API (éœ€ä¿è­·ï¼) ---
@app.route('/api/reports', methods=['GET'])
@login_required 
def get_reservation_reports():
    filter_type = request.args.get('filter', 'all') 
    
    with app.app_context():
        query = ReservationRecord.query
        
        if filter_type == 'yesterday':
            yesterday = date.today() - timedelta(days=1)
            start_of_yesterday = datetime.combine(yesterday, datetime.min.time())
            end_of_yesterday = datetime.combine(yesterday, datetime.max.time())
            query = query.filter(ReservationRecord.timestamp >= start_of_yesterday, ReservationRecord.timestamp <= end_of_yesterday)
        elif filter_type == 'today':
            today = date.today()
            start_of_today = datetime.combine(today, datetime.min.time())
            end_of_today = datetime.combine(today, datetime.max.time())
            query = query.filter(ReservationRecord.timestamp >= start_of_today, ReservationRecord.timestamp <= end_of_day)
        
        all_reservations = query.all()
        report_data = [record.to_dict() for record in all_reservations]

        return jsonify(report_data)


# --- A4, A5 (ä¸è®Š) ---
@app.route('/api/export-report', methods=['GET'])
@login_required 
def export_report_api():
    try:
        export_data_to_csv() 
        return send_file(OUTPUT_FILENAME, as_attachment=True)

    except Exception as e:
        print(f"Error exporting report: {e}")
        return jsonify({"success": False, "message": "Failed to export report."}), 500

@app.route('/api/admin-cancel', methods=['POST'])
@login_required 
def admin_cancel_seats():
    data = request.get_json()
    reservation_id = data.get('reservation_id')
    seats_to_cancel = data.get('seats_to_cancel', 0) 
    
    if not reservation_id or not isinstance(seats_to_cancel, int) or seats_to_cancel <= 0:
        return jsonify({"success": False, "message": "Incomplete or invalid request data. Must provide Reservation ID and a positive integer for seats_to_cancel."}), 400

    try:
        with app.app_context():
            reservation_to_cancel = db.session.query(ReservationRecord).filter_by(id=reservation_id).with_for_update().first() 

            if not reservation_to_cancel:
                db.session.rollback()
                return jsonify({"success": False, "message": f"Cancellation failed: Reservation ID {reservation_id} not found."}), 404

            current_seats = reservation_to_cancel.seats_taken
            table_id = reservation_to_cancel.table_id

            if seats_to_cancel > current_seats:
                db.session.rollback()
                return jsonify({
                    "success": False, 
                    "message": f"Cancellation failed: Cannot cancel {seats_to_cancel} seats. Only {current_seats} seats were originally reserved (ID:{reservation_id})."
                }), 409
            
            table = db.session.query(SeatingTable).filter_by(table_id=table_id).with_for_update().first()
            
            table.seats_left += seats_to_cancel
            new_seats_taken = current_seats - seats_to_cancel

            if new_seats_taken == 0:
                db.session.delete(reservation_to_cancel)
                action_message = f"deleted (full cancellation)."
            else:
                reservation_to_cancel.seats_taken = new_seats_taken
                action_message = f"updated to {new_seats_taken} seat(s)."

            db.session.commit()
            
            success_message = (
                f"Admin successfully cancelled {seats_to_cancel} seat(s) from Reservation ID:{reservation_id}. "
                f"The reservation record was {action_message}."
            )

            return jsonify({
                "success": True,
                "message": success_message,
                "reservation_id": reservation_id,
                "new_seats_taken": new_seats_taken,
                "seats_left": table.seats_left 
            })

    except Exception as e:
        db.session.rollback()
        print(f"è³‡æ–™åº«éŒ¯èª¤: {e}")
        return jsonify({"success": False, "message": "Internal server error. Cancellation failed."}), 500


# --- 9. è³‡æ–™åº«åˆå§‹åŒ–å‡½æ•¸ (ä¸è®Š) ---
def initialize_database():
    """å‰µå»ºè³‡æ–™åº«ä¸¦å¯«å…¥åˆå§‹åº§ä½æ•¸æ“š"""
    with app.app_context():
        db.create_all()
        
        if SeatingTable.query.count() == 0:
            print("--- Initializing seating data... ---")
            for table_id, data in INITIAL_SEATING_DATA.items():
                table = SeatingTable(
                    table_id=table_id,
                    zone=data['zone'],
                    total_seats=data['total'],
                    seats_left=data['total']
                )
                db.session.add(table)
            db.session.commit()
            print("--- Seating data initialization complete! ---")
        else:
            print("--- Seating data already exists in database. Skipping initialization. ---")

# --- 10. å•Ÿå‹•ä¼ºæœå™¨ (ä¸è®Š) ---
if __name__ == '__main__':
    initialize_database() 
    app.run(host='0.0.0.0', debug=True)
